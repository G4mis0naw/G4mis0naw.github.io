<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Computer Basic】FASM+GDPI</title>
    <url>/2020/04/15/ComputerBasic-fasmgdip/</url>
    <content><![CDATA[<p>大一课程计算机基础，蛮有意思的就整理了一下笔记</p>
<span id="more"></span>

<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><img src="http://rok.gamison.top/note/20200416162245.png" style="zoom:50%;" />

<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format PE GUI 4.0</span><br><span class="line">;声明文件类型</span><br><span class="line">entry start</span><br><span class="line">;程序入口</span><br><span class="line"></span><br><span class="line">include &#x27;win32ax.inc&#x27;</span><br><span class="line">;文件包头</span><br><span class="line"></span><br><span class="line">struct GdiplusStartupInput</span><br><span class="line">  GdiplusVersion dd ?</span><br><span class="line">  DebugEventCallback dd ?</span><br><span class="line">  SuppressBackgroundThread dd ?</span><br><span class="line">  SuppressExternalCodecs dd ?</span><br><span class="line">ends</span><br></pre></td></tr></table></figure>

<p><code>DebugEventCallback</code> 指向回调函数的指针，在调试中为声明和警告调用该回调函数（默认True）</p>
<p><code>SuppressBackgroundThread</code> 若为True则结构体将返回指向hook函数的指针和指向unhook挂钩函数的指针（默认False）</p>
<p><code>SuppressExternalCodecs</code> 是否抑制外部图像编解码器</p>
<p><code>GdiplusVersion dd ?</code> 第三个位置用于表示默认值，如果该位置为 <code>? </code>则说明这是一个没有初始化的数据</p>
<h2 id="idata部分"><a href="#idata部分" class="headerlink" title=".idata部分"></a>.idata部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section &#x27;.idata&#x27; import data readable writeable</span><br><span class="line"></span><br><span class="line">  library gdi, &#x27;GDI.DLL&#x27;,\</span><br><span class="line">          gdiplus, &#x27;GDIPLUS.DLL&#x27;,\</span><br><span class="line">          kernel32,&#x27;KERNEL32.DLL&#x27;,\</span><br><span class="line">          user32,&#x27;USER32.DLL&#x27;</span><br><span class="line"></span><br><span class="line">  include &#x27;api\gdi32.inc&#x27;</span><br><span class="line">  include &#x27;api\kernel32.inc&#x27;</span><br><span class="line">  include &#x27;api\user32.inc&#x27;</span><br><span class="line"></span><br><span class="line">  import  gdiplus,\</span><br><span class="line">                  GdiplusShutdown,&#x27;GdiplusShutdown&#x27;,\</span><br><span class="line">                  GdipCreateFromHDC, &#x27;GdipCreateFromHDC&#x27;,\</span><br><span class="line">                  GdipCreatePen1, &#x27;GdipCreatePen1&#x27;,\</span><br><span class="line">                  GdipDeleteGraphics, &#x27;GdipDeleteGraphics&#x27;,\</span><br><span class="line">                  GdipDeletePen, &#x27;GdipDeletePen&#x27;,\</span><br><span class="line">                  GdipGetPenBrushFill, &#x27;GdipGetPenBrushFill&#x27;,\</span><br><span class="line">                  GdipFillEllipseI, &#x27;GdipFillEllipseI&#x27;,\</span><br><span class="line">                  GdipDrawLineI, &#x27;GdipDrawLineI&#x27;,\</span><br><span class="line">                  GdipSetSmoothingMode, &#x27;GdipSetSmoothingMode&#x27;,\</span><br><span class="line">                  GdiplusStartup, &#x27;GdiplusStartup&#x27;,\</span><br><span class="line">                  GdipDrawEllipseI, &#x27;GdipDrawEllipseI&#x27;,\</span><br><span class="line">                  GdipDrawArcI, &#x27;GdipDrawArcI&#x27;,\</span><br><span class="line">                  GdipDrawRectangleI, &#x27;GdipDrawRectangleI&#x27;,\</span><br><span class="line">                  GdipFillEllipse, &#x27;GdipFillEllipse&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="data部分"><a href="#data部分" class="headerlink" title=".data部分"></a>.data部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section &#x27;.data&#x27; data readable writeable</span><br><span class="line"></span><br><span class="line">  _class TCHAR &#x27;FASMWIN32&#x27;,0</span><br><span class="line">  _title TCHAR &#x27;Example&#x27;,0</span><br><span class="line">  _error TCHAR &#x27;Startup failed.&#x27;,0</span><br><span class="line"></span><br><span class="line">  wc WNDCLASS 0,WindowProc,0,0,NULL,NULL,NULL,COLOR_BTNFACE+1,NULL,_class</span><br><span class="line">  ;注册一个windows类</span><br><span class="line"></span><br><span class="line">  msg MSG</span><br><span class="line">  input GdiplusStartupInput 1 ; GdiplusVersion = 1</span><br><span class="line">  token dd ? </span><br></pre></td></tr></table></figure>

<p>该部分用于存放全局变量/常量等，用ida查看字符串可以看到上面这三个全局变量</p>
<p><code>WNDCLASS </code>是一个系统支持的结构，用于储存窗口信息</p>
<p><img src="http://rok.gamison.top/note/20200417114255.png"></p>
<img src="http://rok.gamison.top/note/20200417115740.png" style="zoom:67%;" />

<h2 id="code部分"><a href="#code部分" class="headerlink" title=".code部分"></a>.code部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section &#x27;.code&#x27; code readable executable</span><br><span class="line"></span><br><span class="line">  start:</span><br><span class="line"></span><br><span class="line">        invoke  GetModuleHandle,0   </span><br><span class="line">        mov     [wc.hInstance],eax</span><br><span class="line">        invoke  LoadIcon,0,IDI_APPLICATION</span><br><span class="line">        mov     [wc.hIcon],eax</span><br><span class="line">        invoke  LoadCursor,0,IDC_IBEAM;IDC_ARROW</span><br><span class="line">        mov     [wc.hCursor],eax</span><br><span class="line">        invoke  RegisterClass,wc</span><br><span class="line">        test    eax,eax</span><br><span class="line">        jz      error</span><br><span class="line"></span><br><span class="line">        invoke  GdiplusStartup, token, input, NULL </span><br><span class="line">        test    eax, eax</span><br><span class="line">        jnz     error</span><br><span class="line"></span><br><span class="line">        invoke  CreateWindowEx,0,_class,_title,WS_VISIBLE+WS_CAPTION+WS_SYSMENU+WS_THICKFRAME,128,100,740,576,NULL,NULL,[wc.hInstance],NULL</span><br><span class="line">        test    eax,eax</span><br><span class="line">        jz      error</span><br><span class="line"></span><br><span class="line">  msg_loop:</span><br><span class="line">        invoke  GetMessage,msg,NULL,0,0  </span><br><span class="line">        cmp     eax,1 </span><br><span class="line">        jb      end_loop  </span><br><span class="line">        jne     msg_loop</span><br><span class="line">        invoke  TranslateMessage,msg</span><br><span class="line">        invoke  DispatchMessage,msg  </span><br><span class="line">        jmp     msg_loop</span><br><span class="line"></span><br><span class="line">  error:</span><br><span class="line">        invoke  MessageBox,NULL,_error,NULL,MB_ICONERROR+MB_OK</span><br><span class="line"></span><br><span class="line">  end_loop:</span><br><span class="line">        invoke  GdiplusShutdown, [token]</span><br><span class="line">        invoke  ExitProcess,[msg.wParam]  </span><br></pre></td></tr></table></figure>

<p><code>GetModuleHandle</code> 用于获取一个应用程序或动态链接库的模块句柄，前提是目的模块已映射到调用该函数的进程内</p>
<p><code>LoadCursor</code> 从一个与相关的可执行文件中载入指定的光标资源</p>
<p><code>test </code>用于将两个操作数进行逻辑与运算，并根据结果设置标志位（不影响进行运算的两个数本身</p>
<h2 id="窗口进程相关"><a href="#窗口进程相关" class="headerlink" title="窗口进程相关"></a>窗口进程相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc WindowProc hwnd,umsg,wparam,lparam</span><br><span class="line">local ps:PAINTSTRUCT</span><br><span class="line"></span><br><span class="line">        push    ebx esi edi</span><br><span class="line"></span><br><span class="line">        cmp     [wmsg],WM_DESTROY</span><br><span class="line">        je      .wmdestroy</span><br><span class="line"></span><br><span class="line">        cmp     [wmsg], WM_PAINT</span><br><span class="line">        je      .wmpaint</span><br><span class="line"></span><br><span class="line">  .defwndproc:</span><br><span class="line">        invoke  DefWindowProc,[hwnd],[wmsg],[wparam],[lparam]</span><br><span class="line">        jmp     .finish</span><br><span class="line"></span><br><span class="line">  .wmpaint:</span><br><span class="line">        invoke  BeginPaint, [hwnd], addr ps </span><br><span class="line"></span><br><span class="line">        stdcall draw, eax, $FF000000</span><br><span class="line">        invoke  EndPaint, [hwnd], addr ps</span><br><span class="line">        jmp     .finish_ret_0</span><br><span class="line"></span><br><span class="line">  .wmdestroy:</span><br><span class="line">        invoke  PostQuitMessage,0</span><br><span class="line"></span><br><span class="line">  .finish_ret_0:</span><br><span class="line">        xor     eax,eax</span><br><span class="line"></span><br><span class="line">  .finish:</span><br><span class="line">        pop     edi esi ebx</span><br><span class="line">        ret</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>

<p><code>WindowProc</code> 是一个用于处理发送给窗口消息的函数</p>
<p>其中的参数 <code>hwnd</code> 指向窗口的句柄，<code>uMsg</code> 为消息类型，<code>wparam</code> 和<code>lparam</code> 为其它的消息</p>
<h2 id="画画"><a href="#画画" class="headerlink" title="画画"></a>画画</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc draw hdc, color</span><br><span class="line">local pGraphics:DWORD, pPen:DWORD, pBrush:DWORD</span><br><span class="line"></span><br><span class="line">  invoke  GdipCreateFromHDC, [hdc], addr pGraphics</span><br><span class="line">  invoke  GdipCreatePen1, [color], 3.0, 2, addr pPen</span><br><span class="line">  invoke  GdipGetPenBrushFill, [pPen], addr pBrush</span><br><span class="line">  ;创建场景句柄/画笔兑现/刷子对象</span><br><span class="line"></span><br><span class="line">  invoke  GdipSetSmoothingMode, [pGraphics], 2</span><br><span class="line"></span><br><span class="line">  push ebx</span><br><span class="line">  mov ebx, 1</span><br><span class="line">  invoke  GdipDrawRectangleI, [pGraphics], [pPen], addr 250+ebx*8, addr 100+ebx*8, addr 200+ebx*8, addr 200+ebx*8</span><br><span class="line">  invoke  GdipFillEllipseI, [pGraphics], [pBrush], addr 300+ebx*8, addr 140+ebx*8, addr 10+ebx*8, addr 25+ebx*8</span><br><span class="line">  ;以下省略n条画画步骤</span><br><span class="line">  ;[pGraphics]参数是指向对象的指针,[pPen]参数是指向画线的“笔”的指针,后面参数用于画图对象的具体长宽高等</span><br><span class="line">  pop ebx</span><br><span class="line">  ret</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>

<p><code>invoke</code> 用于使用第一个参数间接调用进程（<code>fastcall</code>用于直接调用）</p>
<p><code>lea</code> Load effective address 加载有效地址，将有效地址传送到指定的寄存器</p>
<blockquote>
<p>参考资料：<br><a href="https://flatassembler.net/docs.php?article=win32">FASM官方文档</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记1-SDS数据结构</title>
    <url>/2020/11/07/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>Redis6.0源码及《Redis设计与实现》阅读</p>
<span id="more"></span>

<p>简单动态字符串<code>simple dynamic string</code>, redis中默认的字符串表示。</p>
<p>源码阅读：</p>
<p><code>/src/sds.h</code> &amp; <code>/src/sds.c</code></p>
<h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS有5种不同的类型，使用非字节对齐的结构体让不同的字符串使用不同长度的数据结构，从而节省内存。</p>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p>
<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><p>SDS中获取一个字符串长度的复杂度仅为O(1)，在<code>len</code>属性中已经记录了字符串的长度，获取长度仅需访问属性即可</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>当SDS api需要对SDS进行修改的时候，API会先检查SDS的空间是否满足修改所需的要求，如果不满足，api会自动将SDS空间扩展至执行修改所需要的大小，才进行修改操作，所以这种空间分配策略完全杜绝了发生字符串缓冲区溢出的可能性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by &#x27;t&#x27; of &#x27;len&#x27; bytes to the</span></span><br><span class="line"><span class="comment"> * end of the specified sds string &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查SDS空间是否足够，不够的话通过<code>sdsMakeRoomFor</code>自动为要拼接的字符串拓展空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class="line"><span class="comment"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class="line"><span class="comment"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class="line"><span class="comment"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SDS_MAX_PREALLOC is defined to 1MB according to sds.h.*/</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* Change header if necessary.*/</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><ul>
<li>空间预分配</li>
</ul>
<p>当SDS api对一个sds进行修改并需要对其进行空间扩展的时候，程序还会额外为其分配除了所需的空间之外的未使用空间。</p>
<p>实现方式如上<code>sdsMakeRoomFor</code></p>
<ul>
<li>惰性空间释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove the part of the string from left and from right composed just of</span></span><br><span class="line"><span class="comment"> * contiguous characters found in &#x27;cset&#x27;, that is a null terminted C string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;AA...AA.a.aa.aHelloWorld     :::&quot;);</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,&quot;Aa. :&quot;);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, s);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Output will be just &quot;HelloWorld&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>sdstrim</code>结束后并没有真正释放空间，SDS将多出来的空间作为未使用保存在SDS中，而是修改了结构体中的<code>len</code>属性，这样避免了缩短字符串所需的内存重分配操作，并为将来可能有的增长操作提供了优化。如果有需要真正释放内存空间的时候需要调用<code>sdsRemoveFreeSpace</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reallocate the sds string so that it has no free space at the end. The</span></span><br><span class="line"><span class="comment"> * contained string remains not altered, but next concatenation operations</span></span><br><span class="line"><span class="comment"> * will require a reallocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-oldhdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check what would be the minimum SDS header that is just good enough to</span></span><br><span class="line"><span class="comment">     * fit this string. */</span></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the type is the same, or at least a large enough type is still</span></span><br><span class="line"><span class="comment">     * required, we just realloc(), letting the allocator to do the copy</span></span><br><span class="line"><span class="comment">     * only if really needed. Otherwise if the change is huge, we manually</span></span><br><span class="line"><span class="comment">     * reallocate the string to use the different header type. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;</span><br><span class="line">        newsh = s_realloc(sh, oldhdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制数据的存放"><a href="#二进制数据的存放" class="headerlink" title="二进制数据的存放"></a>二进制数据的存放</h3><p>SDS api会以处理二进制的方式来处理任何放进buf数组的数据并不会对其中的数据作任何限制、过滤或者假设，数据在线写入的时候时什么样子的，被读取的时候就是什么样子的。</p>
<p>例如，SDS使用<code>len</code>属性来判断字符串是否结束而不是空字符。打个不完全恰当的比方，SDS就不会出现类似于php中<code>%00截断</code>的安全问题。</p>
<p>看源码的时候发现这个有趣的函数，意思是可以在手动修改字符串后，使用<code>sdsupdatelen</code>进行字符串长度的更新，即按照空字符进行截断，而不是上述默认的长度判定方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set the sds string length to the length as obtained with strlen(), so</span></span><br><span class="line"><span class="comment"> * considering as content only up to the first null term character.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is useful when the sds string is hacked manually in some</span></span><br><span class="line"><span class="comment"> * way, like in the following example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;foobar&quot;);</span></span><br><span class="line"><span class="comment"> * s[2] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment"> * sdsupdatelen(s);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%d\n&quot;, sdslen(s));</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The output will be &quot;2&quot;, but if we comment out the call to sdsupdatelen()</span></span><br><span class="line"><span class="comment"> * the output will be &quot;6&quot; as the string was modified but the logical length</span></span><br><span class="line"><span class="comment"> * remains 6 bytes. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    sdssetlen(s, reallen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Redis版本：6.0</p>
<p>参考部分《Redis设计与实现》及其作者的源码注释，书中版本为3.0</p>
<p>为了看起来和谐，部分代码中自己添加的注释保持使用英文 :)</p>
<p>参考资料：</p>
<p><a href="http://cs-cjl.com/2019/04_13_redis5_data_structure_1_sds">http://cs-cjl.com/2019/04_13_redis5_data_structure_1_sds</a></p>
<p><a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p>
<p><a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>时间长河中的泊车</title>
    <url>/2021/10/11/%E6%9C%80%E5%90%8E%E7%9A%84%E8%AE%BF%E8%B0%88/</url>
    <content><![CDATA[<p>《博尔赫斯：最后的访谈》</p>
<span id="more"></span>

<blockquote>
<p>就算我们能活一百岁，跟永生或是永恒相比起来都不值得一提。我想，就算我们活了一百岁，如果还能继续或者，我们所做的一切也都无足轻重。如果时间是无穷尽的，大家都会经历所有的事情，那么几千年后，我们每个人可能既是圣人也是杀人犯，是叛徒也是通奸者，是傻瓜也是智者。</p>
</blockquote>
<blockquote>
<p>而当你读某本书时，你却在字里行间探寻作者的弦外之音，最后你不得不编造出种种理由来自圆其说。</p>
</blockquote>
<blockquote>
<p>莱库韦：所以您还是一个坚定的反庇隆主义者。我原以为从您发表过的某些言论来看，您已经在一定程度上选择原谅。</p>
<p>博尔赫斯：是遗忘，不是原谅。遗忘是宽恕的唯一形式，也是复仇和惩罚的唯一形式，因为如果我的对手知道我还在想着他们，从某种意义上说我就成了他们的奴隶，但如果我把他们都忘了，就不会陷入这种处境。我认为原谅和复仇这两个词指代的是同一种东西，那就是遗忘。但人们往往不会轻易遗忘一桩错事。</p>
</blockquote>
<blockquote>
<p>我这辈子从来没看过报纸。那是因为我发现时效只有一天的东西重要不到哪里去，他们把这些东西称之为日报，听着就让人对它的重要性产生不了多少信心，不是吗？</p>
</blockquote>
<blockquote>
<p>不是自愿的，但我会说谎。语言远远不足以充分表达我们的思想和感受，因此我们不得不说谎。史蒂文森曾经说过，任何一个人在短短五分钟内经历的事，就算你有莎士比亚的词汇量和才华都不能详尽地表述出来。语言实在是一种非常拙劣的工具，这逼得你不得不说谎。如果你指的是故意说谎？不，我会尽量不说谎。</p>
</blockquote>
<blockquote>
<p>如果你想颠覆某种已有的事物，你必须先证明一点，那就是前人能做到的你也能做到。你不能一上来就革新。</p>
</blockquote>
<blockquote>
<p>假设我现在正在读史蒂文森的书，我会觉得自己既不在英国，也不在南美，而是身在书中描绘的世界里。但那本书也可能泄露了一个和我有关的秘密，或者我的某个隐秘的内心活动。不过，这两种说法是可以并存的。</p>
</blockquote>
<blockquote>
<p>但不知道怎么回事，会让别人觉得我很冷酷无情。但不知怎么回事，我从未对广岛的遭遇有过任何激烈的情绪。也许这确实是一场前所未有的人间惨剧，但我认为如果你接受了战争，你就不得不接受它的残酷性，接受屠杀、血洗之类的暴行。归根结底，被步枪扫射而死和被人用石头砸死或者用刀捅死，从本质上来说没有任何区别。轰炸广岛之所以特别骇人听闻，是因为牵连了太多无辜的平民，而且持续的时间又特别短。但说到底，我看不出轰炸广岛和其他战争——我这么说是为了便于讨论——或者说广岛事件和人一生的遭遇之之间有什么区别。我是说发生在广岛的这一整出悲剧被压缩得无比紧凑，能让你尽收眼底，深感震撼。但一个人从长大成人，到生病，再到死亡的整个过程正像是一出延时版的广岛事件。</p>
</blockquote>
<blockquote>
<p>伯金：我不想做过度的诠释，但提到这首诗是因为， 它似乎告诉我们爱情是人唯一能看到或者是知晓的事物。</p>
<p>博尔赫斯：是的，可能是。但我认为说不好，我那样写要更含蓄一些。我在创作那首诗时，心里想的并不是一般的情况，我想的是某个非常具体的女孩，她对我的冷漠也确有其事。那阵子我很不开心。当然了，写完那首诗之后我轻松多了。因为那你一旦把某件事诉诸笔墨之后，就等于把它从你身体中剥离出去了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Else</tag>
      </tags>
  </entry>
  <entry>
    <title>【Computer Basic】Graphic And Assembly Basic</title>
    <url>/2020/04/16/graphic-and-assembly-basic/</url>
    <content><![CDATA[<p>大一课程计算机基础，蛮有意思的就整理了一下笔记</p>
<span id="more"></span>

<h2 id="Imagine-methods"><a href="#Imagine-methods" class="headerlink" title="Imagine methods"></a>Imagine methods</h2><p>pixel 像素</p>
<p>screen resolution 屏幕像素</p>
<ul>
<li>Raster graphics 栅格图像</li>
<li>Vector Graphics</li>
<li>Fractal</li>
</ul>
<img src="http://rok.gamison.top/note/20200414232652.png" style="zoom: 67%;" />

<h2 id="Color-Model"><a href="#Color-Model" class="headerlink" title="Color Model"></a>Color Model</h2><ul>
<li>RGB - red, green and blue</li>
<li>CMYK</li>
<li>HSL &amp; HSV - hue, saturation &amp; lightness / value</li>
</ul>
<h2 id="Graphics-Adapters"><a href="#Graphics-Adapters" class="headerlink" title="Graphics Adapters"></a>Graphics Adapters</h2><p>Components mounted on a video card:</p>
<ul>
<li>GPU -  graphics processing unit</li>
<li>video BIOS</li>
<li>heatvideo memory</li>
<li>RAMDAC</li>
<li>heat sink</li>
<li>output interfaces</li>
<li>power supply</li>
</ul>
<p>A graphics adapter is an electronic board that transform graphic data (text, pictures,video) into a video signal for a monitor.</p>
<p><strong>Memory organization in graphics adapters</strong></p>
<p>CGA - Color Graphic Adapter 彩色图形适配器</p>
<p>EGA - Enhanced Graphic Adapter 增强图形适配器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; fill the screen with bright white color </span><br><span class="line">MOV AX, 0A000h ; start address of the video memory </span><br><span class="line">MOV ES, AX</span><br><span class="line">XOR DI, DI ; clearing the index register </span><br><span class="line">MOV CX, 8000 ; program sequence counter</span><br><span class="line">MOV AL, 0Fh ; set the code into white</span><br><span class="line">REP STOSB</span><br></pre></td></tr></table></figure>

<p>VGA - Video Graphics Array 视频图形阵列</p>
<h2 id="GDI"><a href="#GDI" class="headerlink" title="GDI"></a>GDI</h2><p>Graphics Device Interface</p>
<p><strong>GDI + kernel + Windows API -&gt; Microsoft Windows user interface</strong></p>
<p><code>DC</code> Device Context</p>
<p><code>HDC</code> Handle DC</p>
<h2 id="Assembly-Basic"><a href="#Assembly-Basic" class="headerlink" title="Assembly Basic"></a>Assembly Basic</h2><p><code>EAX</code> Accumulator 累加寄存器</p>
<p><code>EBX</code> Base 基地址寄存器</p>
<p><code>ECX</code> Counter 计数寄存器</p>
<p><code>EDX</code> Data 数据寄存器</p>
<p><img src="http://rok.gamison.top/note/20200415113009.png"></p>
<p><strong>Index and pointer registers</strong></p>
<p><code>ESI</code> - Source index 源变址寄存器</p>
<p><code>EDI</code> - Destination index 目的变址寄存器</p>
<p><code>EBP</code> - Extended Base Pointer 栈指针寄存器，永远指向系统栈最上面的一个栈帧的栈顶</p>
<p><code>ESP</code> - Extended Stack Pointer 基址指针寄存器，永远指向系统栈最上面的一个栈帧的栈底</p>
<p> <code>EIP</code> - Index Pointer Register</p>
<p><strong>Segment Registers</strong> </p>
<p>● CS - the code segment register 代码段寄存器用于存放代码</p>
<p>● DS - the data segment register 数据段寄存器存放数据</p>
<p>● SS - the stack segment register 栈段寄存器，相当于堆栈段的首地址</p>
<p>● ES, FG, GS - Some string operations use an optional segment register to control memory addressing. </p>
<p><strong>Variable types</strong></p>
<p><code>db</code> data byte - memory allocation for 1 byte data</p>
<p><code>dw</code>  data word - memory allocation for 2 byte data</p>
<p><code>dd </code> double word - memory allocation for 4 byte data</p>
<p><code>df</code> double word - memory allocation for 6 byte data</p>
<p><code>dq</code> double word - memory allocation for 8 byte data</p>
<h2 id="FASM"><a href="#FASM" class="headerlink" title="FASM"></a>FASM</h2><p>一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format PE GUI 4 . 0</span><br><span class="line">//声明二进制文件的类型</span><br><span class="line"></span><br><span class="line">entry s t a r t</span><br><span class="line"></span><br><span class="line">include ’win32ax.inc’</span><br><span class="line"></span><br><span class="line">struct GdiplusStartupInput</span><br><span class="line">		GdiplusVers ion dd ?</span><br><span class="line">		DebugEventCallback dd ?</span><br><span class="line">		SuppressBackgroundThread dd ?</span><br><span class="line">		SuppressExternalCodecs dd ?</span><br><span class="line">ends</span><br><span class="line"></span><br><span class="line">library gdi , ’GDI.DLL’, \</span><br><span class="line">		gdiplus , ’GDIPLUS.DLL’,\</span><br><span class="line">		kernel32 , ’KERNEL32.DLL’,\</span><br><span class="line">		user32 , ’USER32.DLL’</span><br><span class="line"></span><br><span class="line">wc WNDCLASS 0, WindowProc, 0, 0,NULL,NULL,NULL,COLORBTNFACE+1,NULL, class</span><br><span class="line">//注册一个windows类</span><br><span class="line"></span><br><span class="line">msg MSG</span><br><span class="line"></span><br><span class="line">invoke GetModuleHandle , 0</span><br><span class="line"></span><br><span class="line">mov [ wc.hInstance ], eax</span><br><span class="line"></span><br><span class="line">invoke LoadCursor , 0 ,IDCARROW</span><br><span class="line"></span><br><span class="line">invoke GdiplusStartup , token , input , Null</span><br><span class="line">//初始化Windows GDI+</span><br><span class="line">//token参数指向一个DW变量的指针，用于接受GDI+的TOKEN.TOKEN,该参数在后期结束释放GDI+资源时使用GdiplusShutdown用到</span><br><span class="line">//input, output参数是指向两个结构体变量的指针：input中包括GDC+版本、指向debug callback函数的指针、压缩相关指令等等</span><br><span class="line"></span><br><span class="line">test eax , eax</span><br><span class="line">//test用于将两个操作数进行逻辑与运算，并根据结果设置标志位</span><br><span class="line">jnz error</span><br><span class="line"></span><br><span class="line">invoke BeginPaint [ hwnd ], paintStructVariable</span><br><span class="line">//为指定窗口进行绘图工作的准备，并将相关信息填充到paintStructVarible结构中</span><br><span class="line"></span><br><span class="line">stdcall draw, EAX, $FF000000</span><br><span class="line"></span><br><span class="line">invoke GdipCreateFromHDC , [ hdc ] , addr pGraphics</span><br><span class="line">//创建相对应的绘图区域</span><br><span class="line"></span><br><span class="line">invoke GdipCreatePen1 , [ color ] , 3 .0 , 2 , addr pPen</span><br><span class="line"></span><br><span class="line">invoke GdipSetSmoothingMode , [ pGraphics ] , 2</span><br><span class="line">//确定渲染质量</span><br><span class="line"></span><br><span class="line">invoke GdipDrawLineI , [ pGraphics ] , [ pPen ] , </span><br><span class="line">	addr 0+ebx ∗8 , addr 100+ebx ∗8 , </span><br><span class="line">	addr 700+ebx ∗8 , addr 400+ebx∗8</span><br><span class="line">//GdipDrawLineI函数用于在两点之间画线</span><br><span class="line">//[pGraphics]参数是指向对象的指针</span><br><span class="line">//[pPen]参数是指向画线的“笔”的指针</span><br><span class="line">//后面参数用于定位起始点和终止点</span><br></pre></td></tr></table></figure>

<p><code>GetModuleHandle</code> 用于获取一个应用程序或动态链接库的模块句柄，前提是目的模块已映射到调用该函数的进程内</p>
<p><code>LoadCursor</code> 从一个与相关的可执行文件中载入指定的光标资源</p>
<p><code>ARGB</code> - Alpha(transparency) + RGB</p>
<blockquote>
<p>参考资料：<br><a href="https://docs.microsoft.com/zh-CN/windows/win32/gdiplus/-gdiplus-gdi-start">Windows API GDI+官方文档</a><br>[关于Gdi+和GdiplusStartup](</p>
</blockquote>
]]></content>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
</search>
