<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Computer Basic-FASM+GDPI</title>
    <url>/2020/04/15/ComputerBasic-fasmgdip/</url>
    <content><![CDATA[<p>大一课程计算机基础，蛮有意思的就整理了一下笔记</p>
<span id="more"></span>

<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><img src="http://rok.gamison.top/note/20200416162245.png" style="zoom:50%;" />

<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format PE GUI 4.0</span><br><span class="line">;声明文件类型</span><br><span class="line">entry start</span><br><span class="line">;程序入口</span><br><span class="line"></span><br><span class="line">include &#x27;win32ax.inc&#x27;</span><br><span class="line">;文件包头</span><br><span class="line"></span><br><span class="line">struct GdiplusStartupInput</span><br><span class="line">  GdiplusVersion dd ?</span><br><span class="line">  DebugEventCallback dd ?</span><br><span class="line">  SuppressBackgroundThread dd ?</span><br><span class="line">  SuppressExternalCodecs dd ?</span><br><span class="line">ends</span><br></pre></td></tr></table></figure>

<p><code>DebugEventCallback</code> 指向回调函数的指针，在调试中为声明和警告调用该回调函数（默认True）</p>
<p><code>SuppressBackgroundThread</code> 若为True则结构体将返回指向hook函数的指针和指向unhook挂钩函数的指针（默认False）</p>
<p><code>SuppressExternalCodecs</code> 是否抑制外部图像编解码器</p>
<p><code>GdiplusVersion dd ?</code> 第三个位置用于表示默认值，如果该位置为 <code>? </code>则说明这是一个没有初始化的数据</p>
<h2 id="idata部分"><a href="#idata部分" class="headerlink" title=".idata部分"></a>.idata部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section &#x27;.idata&#x27; import data readable writeable</span><br><span class="line"></span><br><span class="line">  library gdi, &#x27;GDI.DLL&#x27;,\</span><br><span class="line">          gdiplus, &#x27;GDIPLUS.DLL&#x27;,\</span><br><span class="line">          kernel32,&#x27;KERNEL32.DLL&#x27;,\</span><br><span class="line">          user32,&#x27;USER32.DLL&#x27;</span><br><span class="line"></span><br><span class="line">  include &#x27;api\gdi32.inc&#x27;</span><br><span class="line">  include &#x27;api\kernel32.inc&#x27;</span><br><span class="line">  include &#x27;api\user32.inc&#x27;</span><br><span class="line"></span><br><span class="line">  import  gdiplus,\</span><br><span class="line">                  GdiplusShutdown,&#x27;GdiplusShutdown&#x27;,\</span><br><span class="line">                  GdipCreateFromHDC, &#x27;GdipCreateFromHDC&#x27;,\</span><br><span class="line">                  GdipCreatePen1, &#x27;GdipCreatePen1&#x27;,\</span><br><span class="line">                  GdipDeleteGraphics, &#x27;GdipDeleteGraphics&#x27;,\</span><br><span class="line">                  GdipDeletePen, &#x27;GdipDeletePen&#x27;,\</span><br><span class="line">                  GdipGetPenBrushFill, &#x27;GdipGetPenBrushFill&#x27;,\</span><br><span class="line">                  GdipFillEllipseI, &#x27;GdipFillEllipseI&#x27;,\</span><br><span class="line">                  GdipDrawLineI, &#x27;GdipDrawLineI&#x27;,\</span><br><span class="line">                  GdipSetSmoothingMode, &#x27;GdipSetSmoothingMode&#x27;,\</span><br><span class="line">                  GdiplusStartup, &#x27;GdiplusStartup&#x27;,\</span><br><span class="line">                  GdipDrawEllipseI, &#x27;GdipDrawEllipseI&#x27;,\</span><br><span class="line">                  GdipDrawArcI, &#x27;GdipDrawArcI&#x27;,\</span><br><span class="line">                  GdipDrawRectangleI, &#x27;GdipDrawRectangleI&#x27;,\</span><br><span class="line">                  GdipFillEllipse, &#x27;GdipFillEllipse&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="data部分"><a href="#data部分" class="headerlink" title=".data部分"></a>.data部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section &#x27;.data&#x27; data readable writeable</span><br><span class="line"></span><br><span class="line">  _class TCHAR &#x27;FASMWIN32&#x27;,0</span><br><span class="line">  _title TCHAR &#x27;Example&#x27;,0</span><br><span class="line">  _error TCHAR &#x27;Startup failed.&#x27;,0</span><br><span class="line"></span><br><span class="line">  wc WNDCLASS 0,WindowProc,0,0,NULL,NULL,NULL,COLOR_BTNFACE+1,NULL,_class</span><br><span class="line">  ;注册一个windows类</span><br><span class="line"></span><br><span class="line">  msg MSG</span><br><span class="line">  input GdiplusStartupInput 1 ; GdiplusVersion = 1</span><br><span class="line">  token dd ? </span><br></pre></td></tr></table></figure>

<p>该部分用于存放全局变量/常量等，用ida查看字符串可以看到上面这三个全局变量</p>
<p><code>WNDCLASS </code>是一个系统支持的结构，用于储存窗口信息</p>
<p><img src="http://rok.gamison.top/note/20200417114255.png"></p>
<img src="http://rok.gamison.top/note/20200417115740.png" style="zoom:67%;" />

<h2 id="code部分"><a href="#code部分" class="headerlink" title=".code部分"></a>.code部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section &#x27;.code&#x27; code readable executable</span><br><span class="line"></span><br><span class="line">  start:</span><br><span class="line"></span><br><span class="line">        invoke  GetModuleHandle,0   </span><br><span class="line">        mov     [wc.hInstance],eax</span><br><span class="line">        invoke  LoadIcon,0,IDI_APPLICATION</span><br><span class="line">        mov     [wc.hIcon],eax</span><br><span class="line">        invoke  LoadCursor,0,IDC_IBEAM;IDC_ARROW</span><br><span class="line">        mov     [wc.hCursor],eax</span><br><span class="line">        invoke  RegisterClass,wc</span><br><span class="line">        test    eax,eax</span><br><span class="line">        jz      error</span><br><span class="line"></span><br><span class="line">        invoke  GdiplusStartup, token, input, NULL </span><br><span class="line">        test    eax, eax</span><br><span class="line">        jnz     error</span><br><span class="line"></span><br><span class="line">        invoke  CreateWindowEx,0,_class,_title,WS_VISIBLE+WS_CAPTION+WS_SYSMENU+WS_THICKFRAME,128,100,740,576,NULL,NULL,[wc.hInstance],NULL</span><br><span class="line">        test    eax,eax</span><br><span class="line">        jz      error</span><br><span class="line"></span><br><span class="line">  msg_loop:</span><br><span class="line">        invoke  GetMessage,msg,NULL,0,0  </span><br><span class="line">        cmp     eax,1 </span><br><span class="line">        jb      end_loop  </span><br><span class="line">        jne     msg_loop</span><br><span class="line">        invoke  TranslateMessage,msg</span><br><span class="line">        invoke  DispatchMessage,msg  </span><br><span class="line">        jmp     msg_loop</span><br><span class="line"></span><br><span class="line">  error:</span><br><span class="line">        invoke  MessageBox,NULL,_error,NULL,MB_ICONERROR+MB_OK</span><br><span class="line"></span><br><span class="line">  end_loop:</span><br><span class="line">        invoke  GdiplusShutdown, [token]</span><br><span class="line">        invoke  ExitProcess,[msg.wParam]  </span><br></pre></td></tr></table></figure>

<p><code>GetModuleHandle</code> 用于获取一个应用程序或动态链接库的模块句柄，前提是目的模块已映射到调用该函数的进程内</p>
<p><code>LoadCursor</code> 从一个与相关的可执行文件中载入指定的光标资源</p>
<p><code>test </code>用于将两个操作数进行逻辑与运算，并根据结果设置标志位（不影响进行运算的两个数本身</p>
<h2 id="窗口进程相关"><a href="#窗口进程相关" class="headerlink" title="窗口进程相关"></a>窗口进程相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc WindowProc hwnd,umsg,wparam,lparam</span><br><span class="line">local ps:PAINTSTRUCT</span><br><span class="line"></span><br><span class="line">        push    ebx esi edi</span><br><span class="line"></span><br><span class="line">        cmp     [wmsg],WM_DESTROY</span><br><span class="line">        je      .wmdestroy</span><br><span class="line"></span><br><span class="line">        cmp     [wmsg], WM_PAINT</span><br><span class="line">        je      .wmpaint</span><br><span class="line"></span><br><span class="line">  .defwndproc:</span><br><span class="line">        invoke  DefWindowProc,[hwnd],[wmsg],[wparam],[lparam]</span><br><span class="line">        jmp     .finish</span><br><span class="line"></span><br><span class="line">  .wmpaint:</span><br><span class="line">        invoke  BeginPaint, [hwnd], addr ps </span><br><span class="line"></span><br><span class="line">        stdcall draw, eax, $FF000000</span><br><span class="line">        invoke  EndPaint, [hwnd], addr ps</span><br><span class="line">        jmp     .finish_ret_0</span><br><span class="line"></span><br><span class="line">  .wmdestroy:</span><br><span class="line">        invoke  PostQuitMessage,0</span><br><span class="line"></span><br><span class="line">  .finish_ret_0:</span><br><span class="line">        xor     eax,eax</span><br><span class="line"></span><br><span class="line">  .finish:</span><br><span class="line">        pop     edi esi ebx</span><br><span class="line">        ret</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>

<p><code>WindowProc</code> 是一个用于处理发送给窗口消息的函数</p>
<p>其中的参数 <code>hwnd</code> 指向窗口的句柄，<code>uMsg</code> 为消息类型，<code>wparam</code> 和<code>lparam</code> 为其它的消息</p>
<h2 id="画画"><a href="#画画" class="headerlink" title="画画"></a>画画</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc draw hdc, color</span><br><span class="line">local pGraphics:DWORD, pPen:DWORD, pBrush:DWORD</span><br><span class="line"></span><br><span class="line">  invoke  GdipCreateFromHDC, [hdc], addr pGraphics</span><br><span class="line">  invoke  GdipCreatePen1, [color], 3.0, 2, addr pPen</span><br><span class="line">  invoke  GdipGetPenBrushFill, [pPen], addr pBrush</span><br><span class="line">  ;创建场景句柄/画笔兑现/刷子对象</span><br><span class="line"></span><br><span class="line">  invoke  GdipSetSmoothingMode, [pGraphics], 2</span><br><span class="line"></span><br><span class="line">  push ebx</span><br><span class="line">  mov ebx, 1</span><br><span class="line">  invoke  GdipDrawRectangleI, [pGraphics], [pPen], addr 250+ebx*8, addr 100+ebx*8, addr 200+ebx*8, addr 200+ebx*8</span><br><span class="line">  invoke  GdipFillEllipseI, [pGraphics], [pBrush], addr 300+ebx*8, addr 140+ebx*8, addr 10+ebx*8, addr 25+ebx*8</span><br><span class="line">  ;以下省略n条画画步骤</span><br><span class="line">  ;[pGraphics]参数是指向对象的指针,[pPen]参数是指向画线的“笔”的指针,后面参数用于画图对象的具体长宽高等</span><br><span class="line">  pop ebx</span><br><span class="line">  ret</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>

<p><code>invoke</code> 用于使用第一个参数间接调用进程（<code>fastcall</code>用于直接调用）</p>
<p><code>lea</code> Load effective address 加载有效地址，将有效地址传送到指定的寄存器</p>
<blockquote>
<p>参考资料：<br><a href="https://flatassembler.net/docs.php?article=win32">FASM官方文档</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记1-SDS数据结构</title>
    <url>/2020/11/07/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>Redis6.0源码及《Redis设计与实现》阅读</p>
<span id="more"></span>

<p>简单动态字符串<code>simple dynamic string</code>, redis中默认的字符串表示。</p>
<p>源码阅读：</p>
<p><code>/src/sds.h</code> &amp; <code>/src/sds.c</code></p>
<h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS有5种不同的类型，使用非字节对齐的结构体让不同的字符串使用不同长度的数据结构，从而节省内存。</p>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p>
<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><p>SDS中获取一个字符串长度的复杂度仅为O(1)，在<code>len</code>属性中已经记录了字符串的长度，获取长度仅需访问属性即可</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>当SDS api需要对SDS进行修改的时候，API会先检查SDS的空间是否满足修改所需的要求，如果不满足，api会自动将SDS空间扩展至执行修改所需要的大小，才进行修改操作，所以这种空间分配策略完全杜绝了发生字符串缓冲区溢出的可能性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by &#x27;t&#x27; of &#x27;len&#x27; bytes to the</span></span><br><span class="line"><span class="comment"> * end of the specified sds string &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查SDS空间是否足够，不够的话通过<code>sdsMakeRoomFor</code>自动为要拼接的字符串拓展空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class="line"><span class="comment"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class="line"><span class="comment"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class="line"><span class="comment"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SDS_MAX_PREALLOC is defined to 1MB according to sds.h.*/</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* Change header if necessary.*/</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><ul>
<li>空间预分配</li>
</ul>
<p>当SDS api对一个sds进行修改并需要对其进行空间扩展的时候，程序还会额外为其分配除了所需的空间之外的未使用空间。</p>
<p>实现方式如上<code>sdsMakeRoomFor</code></p>
<ul>
<li>惰性空间释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove the part of the string from left and from right composed just of</span></span><br><span class="line"><span class="comment"> * contiguous characters found in &#x27;cset&#x27;, that is a null terminted C string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;AA...AA.a.aa.aHelloWorld     :::&quot;);</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,&quot;Aa. :&quot;);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, s);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Output will be just &quot;HelloWorld&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>sdstrim</code>结束后并没有真正释放空间，SDS将多出来的空间作为未使用保存在SDS中，而是修改了结构体中的<code>len</code>属性，这样避免了缩短字符串所需的内存重分配操作，并为将来可能有的增长操作提供了优化。如果有需要真正释放内存空间的时候需要调用<code>sdsRemoveFreeSpace</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reallocate the sds string so that it has no free space at the end. The</span></span><br><span class="line"><span class="comment"> * contained string remains not altered, but next concatenation operations</span></span><br><span class="line"><span class="comment"> * will require a reallocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-oldhdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check what would be the minimum SDS header that is just good enough to</span></span><br><span class="line"><span class="comment">     * fit this string. */</span></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the type is the same, or at least a large enough type is still</span></span><br><span class="line"><span class="comment">     * required, we just realloc(), letting the allocator to do the copy</span></span><br><span class="line"><span class="comment">     * only if really needed. Otherwise if the change is huge, we manually</span></span><br><span class="line"><span class="comment">     * reallocate the string to use the different header type. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;</span><br><span class="line">        newsh = s_realloc(sh, oldhdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制数据的存放"><a href="#二进制数据的存放" class="headerlink" title="二进制数据的存放"></a>二进制数据的存放</h3><p>SDS api会以处理二进制的方式来处理任何放进buf数组的数据并不会对其中的数据作任何限制、过滤或者假设，数据在线写入的时候时什么样子的，被读取的时候就是什么样子的。</p>
<p>例如，SDS使用<code>len</code>属性来判断字符串是否结束而不是空字符。打个不完全恰当的比方，SDS就不会出现类似于php中<code>%00截断</code>的安全问题。</p>
<p>看源码的时候发现这个有趣的函数，意思是可以在手动修改字符串后，使用<code>sdsupdatelen</code>进行字符串长度的更新，即按照空字符进行截断，而不是上述默认的长度判定方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set the sds string length to the length as obtained with strlen(), so</span></span><br><span class="line"><span class="comment"> * considering as content only up to the first null term character.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is useful when the sds string is hacked manually in some</span></span><br><span class="line"><span class="comment"> * way, like in the following example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;foobar&quot;);</span></span><br><span class="line"><span class="comment"> * s[2] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment"> * sdsupdatelen(s);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%d\n&quot;, sdslen(s));</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The output will be &quot;2&quot;, but if we comment out the call to sdsupdatelen()</span></span><br><span class="line"><span class="comment"> * the output will be &quot;6&quot; as the string was modified but the logical length</span></span><br><span class="line"><span class="comment"> * remains 6 bytes. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    sdssetlen(s, reallen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Redis版本：6.0</p>
<p>参考部分《Redis设计与实现》及其作者的源码注释，书中版本为3.0</p>
<p>为了看起来和谐，部分代码中自己添加的注释保持使用英文 :)</p>
<p>参考资料：</p>
<p><a href="http://cs-cjl.com/2019/04_13_redis5_data_structure_1_sds">http://cs-cjl.com/2019/04_13_redis5_data_structure_1_sds</a></p>
<p><a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p>
<p><a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Gamison* p2023</title>
    <url>/2023/02/18/Gamison-p2023/</url>
    <content><![CDATA[<p>新征程</p>
<span id="more"></span>

<p><em>标题是一个指向2023的指针。</em></p>
<p>2023是一个新的征程，疫情终于告一段落，我也找到了自己愿意为之奋斗的事情，虽然很多事情在疫情的两年多来是不太如意的，但是新的征程上的希望总能给人带来愉悦的不是么？</p>
<p>在昨天结束了不到4个月的实习，给自己的测试工作画上了一个不算漂亮的句号。这是一家氛围很nice福利不错的年轻公司，也是因为如此很多流程和体制上有模有样但其实并不成熟。我作为一个实习生能做的工作不多，空闲的时候偶尔会去翻一翻大厂的测试技术博客，其实也会发现，哪怕是到了美团的业务规模，功能性测试还是占很大比例，所谓的自动化测试离真正的自动化二字还相差甚远。基本的测试思路要么是用脚本对接口进行测试，要么就是用框架对UI交互进行测试，但不管是哪种，在某些方面也是比不上手动式功能性测试的覆盖面广，而且人工智能在测试方面的应用似乎还有很大的开发空间。所以要说互联网大厂技术岗卷，但仔细看其实还有很多能够涉足开辟的领域，所谓卷也只不过是造轮子的人多了罢。</p>
<p>也是有这次的疫情和实习助力，在2月份收获了肌肉劳损和肺结节，虽然不严重，但是一旦久坐臀部大腿就开始酸痛甚至有扭伤的感觉，同时一停药就一直咳嗽不止，甚至睡着了还在咳。也正是因为这两个毛病，从医院开的药有几个有嗜睡的副作用，每天十一点左右就困得不行躺床上十秒入睡，早上也有了六点半自然醒的生物钟，终于开始回到阳间人的队伍。</p>
<p>2023的征程最终还是回到了考研上，不想再强行逼迫自己去做社交因为大部分都没有什么意义，待在自己的小小圈子里，跟聊得来的人去探讨无穷的乐趣，一切顺其自然，读读论文写写代码再做一些看起来稀奇古怪的作品，或许这就足够了。至于这辈子真要追求些什么，那也不重要了，因为走得再远我始终是个普通人。</p>
<p><img src="http://rok.gamison.top/note/ea5602cf2bf7bab46e3d903535d9f8b.jpg"></p>
]]></content>
      <tags>
        <tag>Else</tag>
      </tags>
  </entry>
  <entry>
    <title>最后的访谈</title>
    <url>/2021/10/11/%E6%9C%80%E5%90%8E%E7%9A%84%E8%AE%BF%E8%B0%88/</url>
    <content><![CDATA[<p>《博尔赫斯：最后的访谈》一些摘录</p>
<span id="more"></span>

<blockquote>
<p>就算我们能活一百岁，跟永生或是永恒相比起来都不值得一提。我想，就算我们活了一百岁，如果还能继续或者，我们所做的一切也都无足轻重。如果时间是无穷尽的，大家都会经历所有的事情，那么几千年后，我们每个人可能既是圣人也是杀人犯，是叛徒也是通奸者，是傻瓜也是智者。</p>
</blockquote>
<blockquote>
<p>而当你读某本书时，你却在字里行间探寻作者的弦外之音，最后你不得不编造出种种理由来自圆其说。</p>
</blockquote>
<blockquote>
<p>莱库韦：所以您还是一个坚定的反庇隆主义者。我原以为从您发表过的某些言论来看，您已经在一定程度上选择原谅。</p>
<p>博尔赫斯：是遗忘，不是原谅。遗忘是宽恕的唯一形式，也是复仇和惩罚的唯一形式，因为如果我的对手知道我还在想着他们，从某种意义上说我就成了他们的奴隶，但如果我把他们都忘了，就不会陷入这种处境。我认为原谅和复仇这两个词指代的是同一种东西，那就是遗忘。但人们往往不会轻易遗忘一桩错事。</p>
</blockquote>
<blockquote>
<p>我这辈子从来没看过报纸。那是因为我发现时效只有一天的东西重要不到哪里去，他们把这些东西称之为日报，听着就让人对它的重要性产生不了多少信心，不是吗？</p>
</blockquote>
<blockquote>
<p>不是自愿的，但我会说谎。语言远远不足以充分表达我们的思想和感受，因此我们不得不说谎。史蒂文森曾经说过，任何一个人在短短五分钟内经历的事，就算你有莎士比亚的词汇量和才华都不能详尽地表述出来。语言实在是一种非常拙劣的工具，这逼得你不得不说谎。如果你指的是故意说谎？不，我会尽量不说谎。</p>
</blockquote>
<blockquote>
<p>如果你想颠覆某种已有的事物，你必须先证明一点，那就是前人能做到的你也能做到。你不能一上来就革新。</p>
</blockquote>
<blockquote>
<p>假设我现在正在读史蒂文森的书，我会觉得自己既不在英国，也不在南美，而是身在书中描绘的世界里。但那本书也可能泄露了一个和我有关的秘密，或者我的某个隐秘的内心活动。不过，这两种说法是可以并存的。</p>
</blockquote>
<blockquote>
<p>但不知道怎么回事，会让别人觉得我很冷酷无情。但不知怎么回事，我从未对广岛的遭遇有过任何激烈的情绪。也许这确实是一场前所未有的人间惨剧，但我认为如果你接受了战争，你就不得不接受它的残酷性，接受屠杀、血洗之类的暴行。归根结底，被步枪扫射而死和被人用石头砸死或者用刀捅死，从本质上来说没有任何区别。轰炸广岛之所以特别骇人听闻，是因为牵连了太多无辜的平民，而且持续的时间又特别短。但说到底，我看不出轰炸广岛和其他战争——我这么说是为了便于讨论——或者说广岛事件和人一生的遭遇之之间有什么区别。我是说发生在广岛的这一整出悲剧被压缩得无比紧凑，能让你尽收眼底，深感震撼。但一个人从长大成人，到生病，再到死亡的整个过程正像是一出延时版的广岛事件。</p>
</blockquote>
<blockquote>
<p>伯金：我不想做过度的诠释，但提到这首诗是因为， 它似乎告诉我们爱情是人唯一能看到或者是知晓的事物。</p>
<p>博尔赫斯：是的，可能是。但我认为说不好，我那样写要更含蓄一些。我在创作那首诗时，心里想的并不是一般的情况，我想的是某个非常具体的女孩，她对我的冷漠也确有其事。那阵子我很不开心。当然了，写完那首诗之后我轻松多了。因为那你一旦把某件事诉诸笔墨之后，就等于把它从你身体中剥离出去了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Else</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Basic-Graphic And Assembly Basic</title>
    <url>/2020/04/16/graphic-and-assembly-basic/</url>
    <content><![CDATA[<p>大一课程计算机基础，蛮有意思的就整理了一下笔记</p>
<span id="more"></span>

<h2 id="Imagine-methods"><a href="#Imagine-methods" class="headerlink" title="Imagine methods"></a>Imagine methods</h2><p>pixel 像素</p>
<p>screen resolution 屏幕像素</p>
<ul>
<li>Raster graphics 栅格图像</li>
<li>Vector Graphics</li>
<li>Fractal</li>
</ul>
<img src="http://rok.gamison.top/note/20200414232652.png" style="zoom: 67%;" />

<h2 id="Color-Model"><a href="#Color-Model" class="headerlink" title="Color Model"></a>Color Model</h2><ul>
<li>RGB - red, green and blue</li>
<li>CMYK</li>
<li>HSL &amp; HSV - hue, saturation &amp; lightness / value</li>
</ul>
<h2 id="Graphics-Adapters"><a href="#Graphics-Adapters" class="headerlink" title="Graphics Adapters"></a>Graphics Adapters</h2><p>Components mounted on a video card:</p>
<ul>
<li>GPU -  graphics processing unit</li>
<li>video BIOS</li>
<li>heatvideo memory</li>
<li>RAMDAC</li>
<li>heat sink</li>
<li>output interfaces</li>
<li>power supply</li>
</ul>
<p>A graphics adapter is an electronic board that transform graphic data (text, pictures,video) into a video signal for a monitor.</p>
<p><strong>Memory organization in graphics adapters</strong></p>
<p>CGA - Color Graphic Adapter 彩色图形适配器</p>
<p>EGA - Enhanced Graphic Adapter 增强图形适配器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; fill the screen with bright white color </span><br><span class="line">MOV AX, 0A000h ; start address of the video memory </span><br><span class="line">MOV ES, AX</span><br><span class="line">XOR DI, DI ; clearing the index register </span><br><span class="line">MOV CX, 8000 ; program sequence counter</span><br><span class="line">MOV AL, 0Fh ; set the code into white</span><br><span class="line">REP STOSB</span><br></pre></td></tr></table></figure>

<p>VGA - Video Graphics Array 视频图形阵列</p>
<h2 id="GDI"><a href="#GDI" class="headerlink" title="GDI"></a>GDI</h2><p>Graphics Device Interface</p>
<p><strong>GDI + kernel + Windows API -&gt; Microsoft Windows user interface</strong></p>
<p><code>DC</code> Device Context</p>
<p><code>HDC</code> Handle DC</p>
<h2 id="Assembly-Basic"><a href="#Assembly-Basic" class="headerlink" title="Assembly Basic"></a>Assembly Basic</h2><p><code>EAX</code> Accumulator 累加寄存器</p>
<p><code>EBX</code> Base 基地址寄存器</p>
<p><code>ECX</code> Counter 计数寄存器</p>
<p><code>EDX</code> Data 数据寄存器</p>
<p><img src="http://rok.gamison.top/note/20200415113009.png"></p>
<p><strong>Index and pointer registers</strong></p>
<p><code>ESI</code> - Source index 源变址寄存器</p>
<p><code>EDI</code> - Destination index 目的变址寄存器</p>
<p><code>EBP</code> - Extended Base Pointer 栈指针寄存器，永远指向系统栈最上面的一个栈帧的栈顶</p>
<p><code>ESP</code> - Extended Stack Pointer 基址指针寄存器，永远指向系统栈最上面的一个栈帧的栈底</p>
<p> <code>EIP</code> - Index Pointer Register</p>
<p><strong>Segment Registers</strong> </p>
<p>● CS - the code segment register 代码段寄存器用于存放代码</p>
<p>● DS - the data segment register 数据段寄存器存放数据</p>
<p>● SS - the stack segment register 栈段寄存器，相当于堆栈段的首地址</p>
<p>● ES, FG, GS - Some string operations use an optional segment register to control memory addressing. </p>
<p><strong>Variable types</strong></p>
<p><code>db</code> data byte - memory allocation for 1 byte data</p>
<p><code>dw</code>  data word - memory allocation for 2 byte data</p>
<p><code>dd </code> double word - memory allocation for 4 byte data</p>
<p><code>df</code> double word - memory allocation for 6 byte data</p>
<p><code>dq</code> double word - memory allocation for 8 byte data</p>
<h2 id="FASM"><a href="#FASM" class="headerlink" title="FASM"></a>FASM</h2><p>一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format PE GUI 4 . 0</span><br><span class="line">//声明二进制文件的类型</span><br><span class="line"></span><br><span class="line">entry s t a r t</span><br><span class="line"></span><br><span class="line">include ’win32ax.inc’</span><br><span class="line"></span><br><span class="line">struct GdiplusStartupInput</span><br><span class="line">		GdiplusVers ion dd ?</span><br><span class="line">		DebugEventCallback dd ?</span><br><span class="line">		SuppressBackgroundThread dd ?</span><br><span class="line">		SuppressExternalCodecs dd ?</span><br><span class="line">ends</span><br><span class="line"></span><br><span class="line">library gdi , ’GDI.DLL’, \</span><br><span class="line">		gdiplus , ’GDIPLUS.DLL’,\</span><br><span class="line">		kernel32 , ’KERNEL32.DLL’,\</span><br><span class="line">		user32 , ’USER32.DLL’</span><br><span class="line"></span><br><span class="line">wc WNDCLASS 0, WindowProc, 0, 0,NULL,NULL,NULL,COLORBTNFACE+1,NULL, class</span><br><span class="line">//注册一个windows类</span><br><span class="line"></span><br><span class="line">msg MSG</span><br><span class="line"></span><br><span class="line">invoke GetModuleHandle , 0</span><br><span class="line"></span><br><span class="line">mov [ wc.hInstance ], eax</span><br><span class="line"></span><br><span class="line">invoke LoadCursor , 0 ,IDCARROW</span><br><span class="line"></span><br><span class="line">invoke GdiplusStartup , token , input , Null</span><br><span class="line">//初始化Windows GDI+</span><br><span class="line">//token参数指向一个DW变量的指针，用于接受GDI+的TOKEN.TOKEN,该参数在后期结束释放GDI+资源时使用GdiplusShutdown用到</span><br><span class="line">//input, output参数是指向两个结构体变量的指针：input中包括GDC+版本、指向debug callback函数的指针、压缩相关指令等等</span><br><span class="line"></span><br><span class="line">test eax , eax</span><br><span class="line">//test用于将两个操作数进行逻辑与运算，并根据结果设置标志位</span><br><span class="line">jnz error</span><br><span class="line"></span><br><span class="line">invoke BeginPaint [ hwnd ], paintStructVariable</span><br><span class="line">//为指定窗口进行绘图工作的准备，并将相关信息填充到paintStructVarible结构中</span><br><span class="line"></span><br><span class="line">stdcall draw, EAX, $FF000000</span><br><span class="line"></span><br><span class="line">invoke GdipCreateFromHDC , [ hdc ] , addr pGraphics</span><br><span class="line">//创建相对应的绘图区域</span><br><span class="line"></span><br><span class="line">invoke GdipCreatePen1 , [ color ] , 3 .0 , 2 , addr pPen</span><br><span class="line"></span><br><span class="line">invoke GdipSetSmoothingMode , [ pGraphics ] , 2</span><br><span class="line">//确定渲染质量</span><br><span class="line"></span><br><span class="line">invoke GdipDrawLineI , [ pGraphics ] , [ pPen ] , </span><br><span class="line">	addr 0+ebx ∗8 , addr 100+ebx ∗8 , </span><br><span class="line">	addr 700+ebx ∗8 , addr 400+ebx∗8</span><br><span class="line">//GdipDrawLineI函数用于在两点之间画线</span><br><span class="line">//[pGraphics]参数是指向对象的指针</span><br><span class="line">//[pPen]参数是指向画线的“笔”的指针</span><br><span class="line">//后面参数用于定位起始点和终止点</span><br></pre></td></tr></table></figure>

<p><code>GetModuleHandle</code> 用于获取一个应用程序或动态链接库的模块句柄，前提是目的模块已映射到调用该函数的进程内</p>
<p><code>LoadCursor</code> 从一个与相关的可执行文件中载入指定的光标资源</p>
<p><code>ARGB</code> - Alpha(transparency) + RGB</p>
<blockquote>
<p>参考资料：<br><a href="https://docs.microsoft.com/zh-CN/windows/win32/gdiplus/-gdiplus-gdi-start">Windows API GDI+官方文档</a><br>[关于Gdi+和GdiplusStartup](</p>
</blockquote>
]]></content>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘检测和高斯模糊入门版</title>
    <url>/2022/03/19/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%92%8C%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E5%85%A5%E9%97%A8%E7%89%88/</url>
    <content><![CDATA[<p>每次等知识真的用上了才会想为啥当初不再认真点听课，卷积暂时也没有整的很明白，尽力去理解和表达一下。</p>
<p>卷积？卷鸭！</p>
<span id="more"></span>

<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘检测本质是<strong>高通滤波器</strong>，下面的图用于说明一张图片上高通和低通部分的区别。</p>
<p><img src="http://rok.gamison.top/note/20220316083933.png"></p>
<h3 id="先说说卷积和卷积核"><a href="#先说说卷积和卷积核" class="headerlink" title="先说说卷积和卷积核"></a>先说说卷积和卷积核</h3><p>卷积就是用卷积核对图像中每个像素进行一系列操作，而卷积核的中心是放在当前要处理的像素上，对于每一个当前像素，计算领域像素和滤波器矩阵对应元素的乘积，然后求和就得到了当前像素的值。</p>
<p><img src="http://rok.gamison.top/note/20220319170856.png"></p>
<p>边缘检测的原理就是找到有着明显差别的颜色、亮度或纹理等属性的相邻像素，对应到数学知识上，这种差值可以用梯度 (gradient)来表示，即边缘处的梯度是比较大的。进而我们引入了边缘检测算子的概念，而我们常用的几个算子都包含了两个方向上的卷积核，即水平和数值；在进行边缘检测时，我们对每个像素进行一次卷积计算，得到两个方向上的梯度值G<sub>x</sub>和G<sub>y</sub>，然后通过下面的公式计算整体梯度</p>
<p><img src="http://rok.gamison.top/note/20220319171617.png"></p>
<p>有时候出于性能考虑，可以使用绝对值代替开根号的操作：</p>
<p><img src="http://rok.gamison.top/note/20220319171715.png"></p>
<p>梯度方向：</p>
<p><img src="http://rok.gamison.top/note/20220319171741.png"></p>
<p>得到梯度G后，我们可以来判断哪些像素对应了边缘，即梯度值越大越可能是边界。</p>
<h3 id="几种常见的边缘检测算子"><a href="#几种常见的边缘检测算子" class="headerlink" title="几种常见的边缘检测算子"></a>几种常见的边缘检测算子</h3><h4 id="Roberts算子"><a href="#Roberts算子" class="headerlink" title="Roberts算子"></a>Roberts算子</h4><p>在进行Roberts算子的实现的时候，《Unity Shader入门精要》上给出的矩阵是</p>
<p><img src="http://rok.gamison.top/note/image-20220316093808105.png"></p>
<p>而在ITMO的Image Processing课程上给出的是符号和位置不同的</p>
<p><img src="http://rok.gamison.top/note/image-20220316094009306.png"></p>
<p>我们直接在OpenCV-Python中看一下三种形式算子得到的结果，可以看出第一张图和后两张的边界清晰度是不同的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roberts</span>():</span></span><br><span class="line">    <span class="comment"># 第一张图</span></span><br><span class="line">    G_x = np.array([[<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">    G_y = np.array([[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二张图</span></span><br><span class="line">    G_x = np.array([[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">    G_y = np.array([[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三张图</span></span><br><span class="line">    G_x = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">    G_y = np.array([[<span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img.dtype == np.uint8:</span><br><span class="line">        img_filter = img.astype(np.float32) / <span class="number">255</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img_filter = np.copy(img)</span><br><span class="line"></span><br><span class="line">    I_x = cv.filter2D(img_filter, -<span class="number">1</span>, G_x)</span><br><span class="line">    I_y = cv.filter2D(img_filter, -<span class="number">1</span>, G_y)</span><br><span class="line"></span><br><span class="line">    img_filter = cv.magnitude(I_x, I_y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img.dtype == np.uint8:</span><br><span class="line">        img_filter = (<span class="number">255</span> * img_filter).clip(<span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&quot;Image1&quot;</span>, img)</span><br><span class="line">    cv.imshow(<span class="string">&quot;Result1&quot;</span>, img_filter)</span><br><span class="line">    cv.waitKey()</span><br></pre></td></tr></table></figure>

<p><img src="http://rok.gamison.top/note/image-20220316091658021.png"></p>
<p><img src="http://rok.gamison.top/note/image-20220316092130056.png"></p>
<p><img src="http://rok.gamison.top/note/image-20220316132227778.png"></p>
<p>为了探究Roberts算子的值的位置所造成的不同结果，我们先要明白下这个二阶算子的原理（按第一种矩阵来说明）</p>
<p>Roberts算子是基于交叉差分的梯度算法；本质是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据；常用于处理具有陡峭低噪声的图像，当边缘比较接近45度的时候算法处理比较理想，缺点是对边缘的定位不准确，提取的边缘线条比较粗。</p>
<p>因此我们谈到Roberts算子，一般使用的是具有对角值的矩阵，而非对角值矩阵所产生的边界会没有那么明显。</p>
<h4 id="Prewitt算子及效果图"><a href="#Prewitt算子及效果图" class="headerlink" title="Prewitt算子及效果图"></a>Prewitt算子及效果图</h4><p>Prewitt算子对噪声有抑制作用，通过先对图像进行一个方向的归一化均值平滑，然后进行该方向的差分；但是Prewitt对于边缘的定位没有Roberts算子准确。</p>
<p><img src="http://rok.gamison.top/note/20220317232036.png"></p>
<p><img src="http://rok.gamison.top/note/image-20220319152400680.png"></p>
<h4 id="Sobel算子及效果图"><a href="#Sobel算子及效果图" class="headerlink" title="Sobel算子及效果图"></a>Sobel算子及效果图</h4><p><img src="http://rok.gamison.top/note/20220317232052.png"></p>
<p><img src="http://rok.gamison.top/note/20220319152555.png"></p>
<h4 id="在Unity中实现Sobel算子"><a href="#在Unity中实现Sobel算子" class="headerlink" title="在Unity中实现Sobel算子"></a>在Unity中实现Sobel算子</h4><p>以Sobel算子为例</p>
<ul>
<li>创建EdgeDetection的C#脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetection : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float edgesOnly = 0.0f;</span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        if (material != null) &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PostEffectBase</code>基类提供检测相关shader和材质的函数，实现<code> OnRenderImage</code>获取当前屏幕渲染的纹理，将参数设置为相应的数值，调用<code>Graphics.Blit</code>使用特定的unity shader对当前图像进行处理，再把返回的渲染纹理显示到屏幕上</p>
<ul>
<li>创建相应的shader</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/EdgeDetection&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Albedo (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                </span><br><span class="line">				<span class="comment">//定义维数为9的纹理数组，对应使用卷积核采样时所需要的9个邻域纹理坐标</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed luminance(fixed4 color) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half Sobel(v2f i) &#123;</span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">//利用Sobel函数计算当前像素的梯度值，并用这个梯度值分别计算背景为原图和纯色下的颜色值，利用_EdgeOnly在两者之间进行插值得到最终的像素值</span></span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_MainTex_TexelSize</code>是Unity为提供的访问某纹理对应的每个纹素的大小：如一张512x512的纹理，值为1/512；因为卷积需要对邻近区域内的纹理进行采样，所以需要用到这个值来计算各个相邻区域的纹理坐标</p>
<ul>
<li>将脚本附到摄像机上</li>
</ul>
<p><img src="http://rok.gamison.top/note/image-20220319000044232.png"></p>
<p><code>edgesOnly</code>参数用于调整边缘线强度：当值为0时，边缘会叠加在原渲染图像上；当值为1时，只会显示边缘，不显示原渲染图像</p>
<p>EdgesOnly为0时：</p>
<p><img src="http://rok.gamison.top/note/20220319000351.png"></p>
<p>EdgesOnly为1时：</p>
<p><img src="http://rok.gamison.top/note/20220319000320.png"></p>
<h4 id="在Unity中实现Roberts算子"><a href="#在Unity中实现Roberts算子" class="headerlink" title="在Unity中实现Roberts算子"></a>在Unity中实现Roberts算子</h4><ul>
<li>脚本代码在Sobel算子的基础上添加一些新的属性，用于控制采样距离以及对深度和法线进行边缘检测时的灵敏度参数，并在后续<code>OnRenderImage</code>函数中将参数传递给材质</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Range(0.0f, 1.0f)]</span><br><span class="line">public float edgesOnly = 0.0f;</span><br><span class="line">public Color edgeColor = Color.black;</span><br><span class="line">public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">public float sampleDistance = 1.0f;</span><br><span class="line">public float sensitivityDepth = 1.0f;</span><br><span class="line">public float sensitivityNormals = 1.0f;</span><br><span class="line"></span><br><span class="line">void OnEnable() &#123;</span><br><span class="line">		GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">[ImageEffectOpaque]</span><br><span class="line">void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">    if (material != null) &#123;</span><br><span class="line">        material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">        material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">        material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line">        material.SetFloat(&quot;_SampleDistance&quot;, sampleDistance);</span><br><span class="line">        material.SetVector(&quot;_Sensitivity&quot;, new Vector4(sensitivityNormals, sensitivityDepth, 0.0f, 0.0f));</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(src, dest, material);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[ImageEffectOpaque]属性使OnRenderImage函数在不透明的pass执行完毕后调用，而不对不透明物体产生影响；因此在<strong>对不透明物体描边而不希望透明物体也被描边时</strong>添加。</p>
<ul>
<li>对应shader</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Edge Detection Normals And Depth&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//_Sensitivity的xy分量分别对应法线和深度的检测灵敏度；_CameraDepthNormalsTexture声明了需要获取的深度和法线纹理 </span></span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		fixed _EdgeOnly;</span><br><span class="line">		fixed4 _EdgeColor;</span><br><span class="line">		fixed4 _BackgroundColor;</span><br><span class="line">		<span class="type">float</span> _SampleDistance;</span><br><span class="line">		half4 _Sensitivity;</span><br><span class="line">		<span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">		v2f vert(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">				uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//CheckSame函数用于计算对角线上两个纹理值的差值，返回值为0代表两点之间存在边界，否则为1；首先通过使用xy分量获得采样点的法线和深度值</span></span><br><span class="line">		half CheckSame(half4 center, half4 <span class="keyword">sample</span>) &#123;</span><br><span class="line">			half2 centerNormal = center.xy;</span><br><span class="line">			<span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">			half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">			<span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line">			</span><br><span class="line">			half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">			<span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">			<span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">			<span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line">			half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">			half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">			half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">			half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">			</span><br><span class="line">			half edge = <span class="number">1.0</span>;</span><br><span class="line">			</span><br><span class="line">			edge *= CheckSame(sample1, sample2);</span><br><span class="line">			edge *= CheckSame(sample3, sample4);</span><br><span class="line">			</span><br><span class="line">			fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">			fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM      </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://rok.gamison.top/note/20220320164717.png"></p>
<p><img src="http://rok.gamison.top/note/20220320164651.png"></p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>高斯模糊本质也是卷积计算，使用的卷积核为高斯核——一个正方形大小的滤波器，每个元素基于以下方程计算，σ为标准差（一般取1），x和y分别对应当前位置到卷积核中心的整数距离。</p>
<p><img src="http://rok.gamison.top/note/20220320162809.png"></p>
<p>计算得到卷积核中各个位置的高斯值后，为保证滤波后图像不会变暗，需要将核中的权重进行归一化——让每个权重除以所有权重的和，保证所有权重的和为1。高斯方程模拟了邻域像素离当前像素越近影响越大，<strong>因此高斯核维数越多，模糊程度越大</strong>。使用一个NxN的高斯核对图像进行卷积滤波，就需要NxNxWxH次纹理采样，因此当维数越多，采样次数会十分巨量。因此，可以将二维的高斯函数拆分成两个一维函数，即使用两个一维高斯核先后对图像进行滤波，采样次数减少为2xNxWxH。</p>
<p><img src="http://rok.gamison.top/note/20220319161008.png"></p>
<h3 id="在OpenCV-Python中实现"><a href="#在OpenCV-Python中实现" class="headerlink" title="在OpenCV-Python中实现"></a>在OpenCV-Python中实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_gauss = cv2.GaussianBlur(img_gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="http://rok.gamison.top/note/20220319164605.png"></p>
<h3 id="在Unity中实现高斯模糊"><a href="#在Unity中实现高斯模糊" class="headerlink" title="在Unity中实现高斯模糊"></a>在Unity中实现高斯模糊</h3><ul>
<li>创建高斯模糊对应的c#脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class GaussianBlur : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader gaussianBlurShader;</span><br><span class="line">    private Material gaussianBlurMaterial = null;</span><br><span class="line"></span><br><span class="line">    public Material material &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            return gaussianBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //三个参数分别对应高斯模糊迭代次数、模糊范围和缩放系数的参数</span><br><span class="line">    [Range(0, 4)]</span><br><span class="line">    public int iterations = 3;</span><br><span class="line"></span><br><span class="line">    [Range(0.2f, 3.0f)]</span><br><span class="line">    public float blurSpread = 0.6f;</span><br><span class="line"></span><br><span class="line">    [Range(1, 8)]</span><br><span class="line">    public int downSample = 2;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        if (material != null) &#123;</span><br><span class="line">            int rtW = src.width/downSample;</span><br><span class="line">            int rtH = src.height/downSample;</span><br><span class="line">            //GetTemporary函数分配了一块小于屏幕图像尺寸的缓冲区，因为高斯模糊的shader中需要调用两个pass，使用一块中间缓存来存储第一个pass执行完毕后得到的模糊结果</span><br><span class="line">            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            //将临时渲染纹理的滤波模式设置为双线性</span><br><span class="line">            buffer.filterMode = FilterMode.Bilinear;</span><br><span class="line">			</span><br><span class="line">            //第一次调用使用shader中第一个pass（即使用竖直方向的一维高斯核进行滤波）对src进行处理，并将结果存储在bufffer中</span><br><span class="line">            Graphics.Blit(src, buffer, material, 0);</span><br><span class="line">            //第二次调用是使用shader中的第二个pass（即使用水平方向的一维高斯核进行滤波）对buffer进行处理，返回最终屏幕的图像</span><br><span class="line">            Graphics.Blit(buffer, dest, material, 1);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高斯核维数相同的情况下，<code>_BlurSize</code>越大模糊程度越高，但采样数不会受到影响；但过大的<code>BlurSize</code>值会造成虚影；而<code>downSample</code>越大，需要处理的像素数越少（性能越好），也能进一步提高模糊程度，但若这个值过大会使图像像素化。</p>
<ul>
<li>创建对应的处理高斯模糊的shader</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/GaussianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">float</span> _BlurSize;</span><br><span class="line">		  </span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">        <span class="comment">//定义一个5维的纹理坐标数组（二维高斯核被拆成两个一维高斯核）；uv[0]为当前的采样纹理，剩下四个坐标则是对邻域采样时使用的纹理坐标</span></span><br><span class="line">		v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//共用的片元着色器</span></span><br><span class="line">		fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">//由上面的高斯核原理图可以看出它是具有对称性的，因此只需要记录3个高斯权重，将结果值sum初始化为当前像素值乘以它的权重值；根据对称性，需要进行两次迭代，并把像素值和权重相乘后的结果叠加到sum中</span></span><br><span class="line">			<span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">			</span><br><span class="line">			fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		    </span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			  </span><br><span class="line">			<span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			  </span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>导入摄像机中</li>
</ul>
<p><img src="http://rok.gamison.top/note/20220319163148.png"></p>
<ul>
<li>模糊结果</li>
</ul>
<p><img src="http://rok.gamison.top/note/20220319163202.png"></p>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>OpenCV</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
</search>
