<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    边缘检测和高斯模糊入门版 |
    
    GaMiSon</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="blog-边缘检测和高斯模糊入门版" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  边缘检测和高斯模糊入门版
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/03/19/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%92%8C%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E5%85%A5%E9%97%A8%E7%89%88/" class="article-date">
  <time datetime="2022-03-19T09:04:23.000Z" itemprop="datePublished">2022-03-19</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>每次等知识真的用上了才会想为啥当初不再认真点听课，卷积暂时也没有整的很明白，尽力去理解和表达一下。</p>
<p>卷积？卷鸭！</p>
<span id="more"></span>

<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘检测本质是<strong>高通滤波器</strong>，下面的图用于说明一张图片上高通和低通部分的区别。</p>
<p><img src="http://rok.gamison.top/note/20220316083933.png"></p>
<h3 id="先说说卷积和卷积核"><a href="#先说说卷积和卷积核" class="headerlink" title="先说说卷积和卷积核"></a>先说说卷积和卷积核</h3><p>卷积就是用卷积核对图像中每个像素进行一系列操作，而卷积核的中心是放在当前要处理的像素上，对于每一个当前像素，计算领域像素和滤波器矩阵对应元素的乘积，然后求和就得到了当前像素的值。</p>
<p><img src="http://rok.gamison.top/note/20220319170856.png"></p>
<p>边缘检测的原理就是找到有着明显差别的颜色、亮度或纹理等属性的相邻像素，对应到数学知识上，这种差值可以用梯度 (gradient)来表示，即边缘处的梯度是比较大的。进而我们引入了边缘检测算子的概念，而我们常用的几个算子都包含了两个方向上的卷积核，即水平和数值；在进行边缘检测时，我们对每个像素进行一次卷积计算，得到两个方向上的梯度值G<sub>x</sub>和G<sub>y</sub>，然后通过下面的公式计算整体梯度</p>
<p><img src="http://rok.gamison.top/note/20220319171617.png"></p>
<p>有时候出于性能考虑，可以使用绝对值代替开根号的操作：</p>
<p><img src="http://rok.gamison.top/note/20220319171715.png"></p>
<p>梯度方向：</p>
<p><img src="http://rok.gamison.top/note/20220319171741.png"></p>
<p>得到梯度G后，我们可以来判断哪些像素对应了边缘，即梯度值越大越可能是边界。</p>
<h3 id="几种常见的边缘检测算子"><a href="#几种常见的边缘检测算子" class="headerlink" title="几种常见的边缘检测算子"></a>几种常见的边缘检测算子</h3><h4 id="Roberts算子"><a href="#Roberts算子" class="headerlink" title="Roberts算子"></a>Roberts算子</h4><p>在进行Roberts算子的实现的时候，《Unity Shader入门精要》上给出的矩阵是</p>
<p><img src="http://rok.gamison.top/note/image-20220316093808105.png"></p>
<p>而在ITMO的Image Processing课程上给出的是符号和位置不同的</p>
<p><img src="http://rok.gamison.top/note/image-20220316094009306.png"></p>
<p>我们直接在OpenCV-Python中看一下三种形式算子得到的结果，可以看出第一张图和后两张的边界清晰度是不同的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roberts</span>():</span></span><br><span class="line">    <span class="comment"># 第一张图</span></span><br><span class="line">    G_x = np.array([[<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">    G_y = np.array([[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二张图</span></span><br><span class="line">    G_x = np.array([[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">    G_y = np.array([[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三张图</span></span><br><span class="line">    G_x = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">    G_y = np.array([[<span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img.dtype == np.uint8:</span><br><span class="line">        img_filter = img.astype(np.float32) / <span class="number">255</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img_filter = np.copy(img)</span><br><span class="line"></span><br><span class="line">    I_x = cv.filter2D(img_filter, -<span class="number">1</span>, G_x)</span><br><span class="line">    I_y = cv.filter2D(img_filter, -<span class="number">1</span>, G_y)</span><br><span class="line"></span><br><span class="line">    img_filter = cv.magnitude(I_x, I_y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img.dtype == np.uint8:</span><br><span class="line">        img_filter = (<span class="number">255</span> * img_filter).clip(<span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&quot;Image1&quot;</span>, img)</span><br><span class="line">    cv.imshow(<span class="string">&quot;Result1&quot;</span>, img_filter)</span><br><span class="line">    cv.waitKey()</span><br></pre></td></tr></table></figure>

<p><img src="http://rok.gamison.top/note/image-20220316091658021.png"></p>
<p><img src="http://rok.gamison.top/note/image-20220316092130056.png"></p>
<p><img src="http://rok.gamison.top/note/image-20220316132227778.png"></p>
<p>为了探究Roberts算子的值的位置所造成的不同结果，我们先要明白下这个二阶算子的原理（按第一种矩阵来说明）</p>
<p>Roberts算子是基于交叉差分的梯度算法；本质是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据；常用于处理具有陡峭低噪声的图像，当边缘比较接近45度的时候算法处理比较理想，缺点是对边缘的定位不准确，提取的边缘线条比较粗。</p>
<p>因此我们谈到Roberts算子，一般使用的是具有对角值的矩阵，而非对角值矩阵所产生的边界会没有那么明显。</p>
<h4 id="Prewitt算子及效果图"><a href="#Prewitt算子及效果图" class="headerlink" title="Prewitt算子及效果图"></a>Prewitt算子及效果图</h4><p>Prewitt算子对噪声有抑制作用，通过先对图像进行一个方向的归一化均值平滑，然后进行该方向的差分；但是Prewitt对于边缘的定位没有Roberts算子准确。</p>
<p><img src="http://rok.gamison.top/note/20220317232036.png"></p>
<p><img src="http://rok.gamison.top/note/image-20220319152400680.png"></p>
<h4 id="Sobel算子及效果图"><a href="#Sobel算子及效果图" class="headerlink" title="Sobel算子及效果图"></a>Sobel算子及效果图</h4><p><img src="http://rok.gamison.top/note/20220317232052.png"></p>
<p><img src="http://rok.gamison.top/note/20220319152555.png"></p>
<h4 id="在Unity中实现Sobel算子"><a href="#在Unity中实现Sobel算子" class="headerlink" title="在Unity中实现Sobel算子"></a>在Unity中实现Sobel算子</h4><p>以Sobel算子为例</p>
<ul>
<li>创建EdgeDetection的C#脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetection : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float edgesOnly = 0.0f;</span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        if (material != null) &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PostEffectBase</code>基类提供检测相关shader和材质的函数，实现<code> OnRenderImage</code>获取当前屏幕渲染的纹理，将参数设置为相应的数值，调用<code>Graphics.Blit</code>使用特定的unity shader对当前图像进行处理，再把返回的渲染纹理显示到屏幕上</p>
<ul>
<li>创建相应的shader</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/EdgeDetection&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Albedo (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                </span><br><span class="line">				<span class="comment">//定义维数为9的纹理数组，对应使用卷积核采样时所需要的9个邻域纹理坐标</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed luminance(fixed4 color) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half Sobel(v2f i) &#123;</span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">//利用Sobel函数计算当前像素的梯度值，并用这个梯度值分别计算背景为原图和纯色下的颜色值，利用_EdgeOnly在两者之间进行插值得到最终的像素值</span></span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_MainTex_TexelSize</code>是Unity为提供的访问某纹理对应的每个纹素的大小：如一张512x512的纹理，值为1/512；因为卷积需要对邻近区域内的纹理进行采样，所以需要用到这个值来计算各个相邻区域的纹理坐标</p>
<ul>
<li>将脚本附到摄像机上</li>
</ul>
<p><img src="http://rok.gamison.top/note/image-20220319000044232.png"></p>
<p><code>edgesOnly</code>参数用于调整边缘线强度：当值为0时，边缘会叠加在原渲染图像上；当值为1时，只会显示边缘，不显示原渲染图像</p>
<p>EdgesOnly为0时：</p>
<p><img src="http://rok.gamison.top/note/20220319000351.png"></p>
<p>EdgesOnly为1时：</p>
<p><img src="http://rok.gamison.top/note/20220319000320.png"></p>
<h4 id="在Unity中实现Roberts算子"><a href="#在Unity中实现Roberts算子" class="headerlink" title="在Unity中实现Roberts算子"></a>在Unity中实现Roberts算子</h4><ul>
<li>脚本代码在Sobel算子的基础上添加一些新的属性，用于控制采样距离以及对深度和法线进行边缘检测时的灵敏度参数，并在后续<code>OnRenderImage</code>函数中将参数传递给材质</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Range(0.0f, 1.0f)]</span><br><span class="line">public float edgesOnly = 0.0f;</span><br><span class="line">public Color edgeColor = Color.black;</span><br><span class="line">public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">public float sampleDistance = 1.0f;</span><br><span class="line">public float sensitivityDepth = 1.0f;</span><br><span class="line">public float sensitivityNormals = 1.0f;</span><br><span class="line"></span><br><span class="line">void OnEnable() &#123;</span><br><span class="line">		GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">[ImageEffectOpaque]</span><br><span class="line">void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">    if (material != null) &#123;</span><br><span class="line">        material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">        material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">        material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line">        material.SetFloat(&quot;_SampleDistance&quot;, sampleDistance);</span><br><span class="line">        material.SetVector(&quot;_Sensitivity&quot;, new Vector4(sensitivityNormals, sensitivityDepth, 0.0f, 0.0f));</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(src, dest, material);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[ImageEffectOpaque]属性使OnRenderImage函数在不透明的pass执行完毕后调用，而不对不透明物体产生影响；因此在<strong>对不透明物体描边而不希望透明物体也被描边时</strong>添加。</p>
<ul>
<li>对应shader</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Edge Detection Normals And Depth&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//_Sensitivity的xy分量分别对应法线和深度的检测灵敏度；_CameraDepthNormalsTexture声明了需要获取的深度和法线纹理 </span></span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		fixed _EdgeOnly;</span><br><span class="line">		fixed4 _EdgeColor;</span><br><span class="line">		fixed4 _BackgroundColor;</span><br><span class="line">		<span class="type">float</span> _SampleDistance;</span><br><span class="line">		half4 _Sensitivity;</span><br><span class="line">		<span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">		v2f vert(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">				uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//CheckSame函数用于计算对角线上两个纹理值的差值，返回值为0代表两点之间存在边界，否则为1；首先通过使用xy分量获得采样点的法线和深度值</span></span><br><span class="line">		half CheckSame(half4 center, half4 <span class="keyword">sample</span>) &#123;</span><br><span class="line">			half2 centerNormal = center.xy;</span><br><span class="line">			<span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">			half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">			<span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line">			</span><br><span class="line">			half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">			<span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">			<span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">			<span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line">			half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">			half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">			half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">			half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">			</span><br><span class="line">			half edge = <span class="number">1.0</span>;</span><br><span class="line">			</span><br><span class="line">			edge *= CheckSame(sample1, sample2);</span><br><span class="line">			edge *= CheckSame(sample3, sample4);</span><br><span class="line">			</span><br><span class="line">			fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">			fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM      </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://rok.gamison.top/note/20220320164717.png"></p>
<p><img src="http://rok.gamison.top/note/20220320164651.png"></p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>高斯模糊本质也是卷积计算，使用的卷积核为高斯核——一个正方形大小的滤波器，每个元素基于以下方程计算，σ为标准差（一般取1），x和y分别对应当前位置到卷积核中心的整数距离。</p>
<p><img src="http://rok.gamison.top/note/20220320162809.png"></p>
<p>计算得到卷积核中各个位置的高斯值后，为保证滤波后图像不会变暗，需要将核中的权重进行归一化——让每个权重除以所有权重的和，保证所有权重的和为1。高斯方程模拟了邻域像素离当前像素越近影响越大，<strong>因此高斯核维数越多，模糊程度越大</strong>。使用一个NxN的高斯核对图像进行卷积滤波，就需要NxNxWxH次纹理采样，因此当维数越多，采样次数会十分巨量。因此，可以将二维的高斯函数拆分成两个一维函数，即使用两个一维高斯核先后对图像进行滤波，采样次数减少为2xNxWxH。</p>
<p><img src="http://rok.gamison.top/note/20220319161008.png"></p>
<h3 id="在OpenCV-Python中实现"><a href="#在OpenCV-Python中实现" class="headerlink" title="在OpenCV-Python中实现"></a>在OpenCV-Python中实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_gauss = cv2.GaussianBlur(img_gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="http://rok.gamison.top/note/20220319164605.png"></p>
<h3 id="在Unity中实现高斯模糊"><a href="#在Unity中实现高斯模糊" class="headerlink" title="在Unity中实现高斯模糊"></a>在Unity中实现高斯模糊</h3><ul>
<li>创建高斯模糊对应的c#脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class GaussianBlur : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader gaussianBlurShader;</span><br><span class="line">    private Material gaussianBlurMaterial = null;</span><br><span class="line"></span><br><span class="line">    public Material material &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            return gaussianBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //三个参数分别对应高斯模糊迭代次数、模糊范围和缩放系数的参数</span><br><span class="line">    [Range(0, 4)]</span><br><span class="line">    public int iterations = 3;</span><br><span class="line"></span><br><span class="line">    [Range(0.2f, 3.0f)]</span><br><span class="line">    public float blurSpread = 0.6f;</span><br><span class="line"></span><br><span class="line">    [Range(1, 8)]</span><br><span class="line">    public int downSample = 2;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        if (material != null) &#123;</span><br><span class="line">            int rtW = src.width/downSample;</span><br><span class="line">            int rtH = src.height/downSample;</span><br><span class="line">            //GetTemporary函数分配了一块小于屏幕图像尺寸的缓冲区，因为高斯模糊的shader中需要调用两个pass，使用一块中间缓存来存储第一个pass执行完毕后得到的模糊结果</span><br><span class="line">            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            //将临时渲染纹理的滤波模式设置为双线性</span><br><span class="line">            buffer.filterMode = FilterMode.Bilinear;</span><br><span class="line">			</span><br><span class="line">            //第一次调用使用shader中第一个pass（即使用竖直方向的一维高斯核进行滤波）对src进行处理，并将结果存储在bufffer中</span><br><span class="line">            Graphics.Blit(src, buffer, material, 0);</span><br><span class="line">            //第二次调用是使用shader中的第二个pass（即使用水平方向的一维高斯核进行滤波）对buffer进行处理，返回最终屏幕的图像</span><br><span class="line">            Graphics.Blit(buffer, dest, material, 1);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高斯核维数相同的情况下，<code>_BlurSize</code>越大模糊程度越高，但采样数不会受到影响；但过大的<code>BlurSize</code>值会造成虚影；而<code>downSample</code>越大，需要处理的像素数越少（性能越好），也能进一步提高模糊程度，但若这个值过大会使图像像素化。</p>
<ul>
<li>创建对应的处理高斯模糊的shader</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/GaussianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">float</span> _BlurSize;</span><br><span class="line">		  </span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">        <span class="comment">//定义一个5维的纹理坐标数组（二维高斯核被拆成两个一维高斯核）；uv[0]为当前的采样纹理，剩下四个坐标则是对邻域采样时使用的纹理坐标</span></span><br><span class="line">		v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//共用的片元着色器</span></span><br><span class="line">		fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">//由上面的高斯核原理图可以看出它是具有对称性的，因此只需要记录3个高斯权重，将结果值sum初始化为当前像素值乘以它的权重值；根据对称性，需要进行两次迭代，并把像素值和权重相乘后的结果叠加到sum中</span></span><br><span class="line">			<span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">			</span><br><span class="line">			fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		    </span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			  </span><br><span class="line">			<span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			  </span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>导入摄像机中</li>
</ul>
<p><img src="http://rok.gamison.top/note/20220319163148.png"></p>
<ul>
<li>模糊结果</li>
</ul>
<p><img src="http://rok.gamison.top/note/20220319163202.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://aw.gamison.top/2022/03/19/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%92%8C%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E5%85%A5%E9%97%A8%E7%89%88/" data-id="clea29q6a000i20uvd0ligmih" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shader/" rel="tag">Shader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2023/02/18/Gamison-p2023/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      Gamison* p2023
      
    </div>
  </a>
  
  
  <a href="/2021/10/11/%E6%9C%80%E5%90%8E%E7%9A%84%E8%AE%BF%E8%B0%88/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">最后的访谈</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>GaMiSon &copy; 2023</li>
      
        <li></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="GaMiSon"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.yuque.com/gamison">Note</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/links">Links</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>